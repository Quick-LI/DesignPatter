# DesignPatter 设计模式

### [创建性设计模式](https://github.com/Quick-LI/DesignPatter/tree/main/src/com/patter/create)

- 单例模式(Singleton pattern)

  -  确保一个类只有一个实例，并提供该实例的全局访问点

- 简单工厂(Simple Factory)

  - 把实例化操作单独放在一个类中，让简单工厂类决定使用哪个子类实例化对象。
  
  - 将客户类和具体子类实现解耦。

- 工厂方法(Factory Method)

  - 定义一个创建对象的接口，由子类决定实例化哪个类。
  
  - 将实例化操作推迟到子类。

- 抽象工厂(Abstract Factory)

  - 提供一个创建一系列相关或相互依赖对象的接口，不需要指定具体使用的类。
  
  - 抽象工厂创建多个对象，并且这些对象是相关或相互依赖的，必须一起创建。

- 生成器(Builder)

  - 将对象的构建和表示分离，使同样的构建过程可以创建不同的表示。
  
  - 封装对象的构造过程，允许按步骤构造。

- 原型模式(Prototype)

  - 使用原型实例指定要创建对象的类型，通过复制原型来创建新对象。

### [结构型设计模式](https://github.com/Quick-LI/DesignPatter/tree/main/src/com/patter/structural)

- 外观(Facade)

  - 提供统一的接口，用来访问子系统中的其他接口。
  
  - 让子系统更容易使用。

- 适配器(Adapter)

  - 将一个类接口转换为另一个用户需要的接口，让接口不兼容的类可以相互合作。

- 桥接(Bridge)

  - 将实现和抽象放在不同的类层次中，使它们可以独立改变。

- 组合(Composite)

  - 将对象组合成树型结构，表示整体/部分层次关系，允许用户用相同的方式处理单独对象和组合对象。
  
  - 组合对象拥有一个或多个组件对象。

- 装饰(Decorator)

  - 向一个现有的对象添加新的功能，同时又不改变其结构

  - 动态地给一个对象添加一些额外的职责。就增加功能，比生成子类更为灵活

- 享元(Flyweight)

  - 利用共享技术有效地支持大量细粒度的对象,减少创建对象的数数量，以减少内存占用
  
  - 将对象的共有部分抽象出来，如果有相同的业务请求，直接返回内存中已有对象，避免重新创建

- 代理(Proxy)
  
  - 为对象提供一个替身或占位符以控制对这个对象的访问
  
  - 为访问对象添加一个对此对象的访问层,一个类代表另一个类的功能

  -  分类
      - 远程代理：控制对远程对象的访问，负责将请求和参数进行编码
      - 虚拟代理：根据需要创建开销很大的对象，可以缓存实体的附加信息，以便延迟对它的访问
      - 保护代理：按权限控制对象的访问，负责检查调用者是否具有实现一个请求所必须的访问权限
      - 智能代理：取代简单的指针，在访问对象时执行一些附加操作

### [行为型设计模式](https://github.com/Quick-LI/DesignPatter/tree/main/src/com/patter/behavioral)

  - 责任链(Chain Of Responsibility)
    
    - 为请求创建对象链，每个对象依序检查此请求并对其进行处理或传给链中的下一个对象
    - 责任链上的处理者负责处理请求，客户只需要将请求发送到责任链上即可，将请求的发送者和处理者解耦

  - 策略(Strategy)
  
    - 一个类的行为或其算法可以在运行时更改
    - 定义一系列的算法，将它们一个个封装起来，并且使它们可相互替换
  
  - 模板方法(Template Method)
  
    -  在方法中定义算法框架，将一些步骤的实现延迟到子类中实现
    
    - 使子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤
  
  - 命令模式(Command)
  
    - 将请求封装成对象，以便使用不同的请求，队列或者日志来参数化其他对象
  
  - 观察者(Observer)

    - 在对象之间定义一对多的依赖，当一个对象改变状态，依赖它的对象都会收到通知并被自动更新
  
  - 访问者(Visitor)
  
    - 封装作用于某种数据结构的各元素的操作，可以在不改变数据结构的前提下定义元素的新操作
    - 元素的执行算法可以随着访问者改变而改变
    
  - 状态(State)
  
    - 允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类
    - 类的行为基于类的状态改变
  
  - 解释器(Interpreter)
  
    - 为语言创建解释器，由语言的语法和语法解析来定义
    - 给定一个语言，定义文法表示，并定义一个解释器，解释器使用标识解释语言中的句子

  - 迭代器(Iterator)
  
    - 提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示
    - 将遍历元素的职责交给迭代器，而不是聚合对象
 
  - 中介者(Mediator)
    
    - 集中相关对象之间复杂的沟通和控制方式，降低多个对象和类之间的通信复杂性
    - 使用中介对象封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松解
  
  - 备忘录(Memento)
    
    - 在不破坏封装性的前提下，捕获对象的内部状态，并在该对象之外保存这个状态
    - 保存一个对象的某个状态，以便在适当的时候恢复对象
    
